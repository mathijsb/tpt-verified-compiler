% !TEX encoding = UTF-8 Unicode
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Short Sectioned Assignment
% LaTeX Template
% Version 1.0 (5/5/12)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% Original author:
% Frits Wenneker (http://www.howtotex.com)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
% PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[paper=a4, fontsize=11pt]{scrartcl} % A4 paper and 11pt font size

\usepackage{dirtree}
\usepackage{listings}

\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs
\usepackage{fourier} % Use the Adobe Utopia font for the document - comment this line to return to the LaTeX default
\usepackage[english, dutch]{babel} % English language/hyphenation
\usepackage{amsmath,amsfonts,amsthm} % Math packages

\usepackage{lipsum} % Used for inserting dummy 'Lorem ipsum' text into the template
\usepackage{graphicx}

\usepackage{sectsty} % Allows customizing section commands
\allsectionsfont{\centering \normalfont\scshape} % Make all sections centered, the default font and small caps

\usepackage{fancyhdr} % Custom headers and footers
\pagestyle{fancyplain} % Makes all pages in the document conform to the custom headers and footers
\fancyhead{} % No page header - if you want one, create it in the same way as the footers below
\fancyfoot[L]{} % Empty left footer
\fancyfoot[C]{} % Empty center footer
\fancyfoot[R]{\thepage} % Page numbering for right footer
\renewcommand{\headrulewidth}{0pt} % Remove header underlines
\renewcommand{\footrulewidth}{0pt} % Remove footer underlines
\setlength{\headheight}{13.6pt} % Customize the height of the header

\usepackage{fancyvrb}
\DefineVerbatimEnvironment{code}{Verbatim}{fontsize=\small}
\DefineVerbatimEnvironment{example}{Verbatim}{fontsize=\small}

\textheight = 720px

\numberwithin{equation}{section} % Number equations within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)
\numberwithin{figure}{section} % Number figures within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)
\numberwithin{table}{section} % Number tables within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)

\setlength\parindent{0pt} % Removes all indentation from paragraphs - comment this line for an assignment with lots of text

%----------------------------------------------------------------------------------------
% TITLE SECTION
%----------------------------------------------------------------------------------------

\newcommand{\horrule}[1]{\rule{\linewidth}{#1}} % Create horizontal rule command with 1 argument of height

\title{ 
\normalfont \normalsize 
\textsc{Universiteit Utrecht, Department of Information and Computing Sciences} \\ [25pt] % Your university, school and/or department name(s)
\horrule{0.5pt} \\[0.4cm] % Thin top horizontal rule
\huge Theory of Programming and Types\\ % The assignment title
\horrule{2pt} \\[0.5cm] % Thick bottom horizontal rule
}

\author{Mathijs Baaijens\\ Nico Naus, 3472353} % Your name

\begin{document}

\maketitle % Print the title

%----------------------------------------------------------------------------------------

\section{abstract}
In this paper we will describe an extension to the type-correct, stack-safe, provably correct expression compiler described in the paper "A type-correct, stack-safe, provably correct expression compiler in Epigram". Our extension adds 'let' bindings to this compiler. We will describe the following components of our extension:
\begin{itemize}
\item{evaluation semantics}
\item{compiler}
\item{interpreter}
\item{correctness proof}
\end{itemize}

\section{Introduction}
\section{The First Semantics : eval}
We start by defining our language. It consists of a simple, typed labda calculus.\\
\\
\ttfamily
data TyExp : Set where\\
  TyNat : TyExp\\
  TyBool : TyExp\\

data Val : TyExp $\rightarrow$ Set where\\
  nat : $\mathbb{N}$ $\rightarrow$ Val TyNat\\
  bool : Bool $\rightarrow$ Val TyBool\\
\normalfont

\ttfamily
-- ** Tuples **\\

data \_x\_ (A B : Set) : Set where\\
  <\_,\_> : A $\rightarrow$ B $\rightarrow$ A x B\\

fst : {A B : Set} $\rightarrow$ A x B $\rightarrow$ A\\
fst < x , y > = x\\

snd : {A B : Set} $\rightarrow$ A x B $\rightarrow$ B\\
snd < x , y > = y\\

-- ** Context **\\

$\Gamma$ = List (Bool x TyExp)\\

-- ** Stack **\\

data Stack : $\Gamma$ $\rightarrow$ Set where\\
  empty : Stack []\\
  \_$\rhd$\_ : $\forall$ {b t s} $\rightarrow$ (v:Val t) $\rightarrow$ (xs : Stack s) $\rightarrow$ Stack (<b,t> :: s)\\

-- ** References **\\

data Ref : $\Gamma$ $\rightarrow$ TyExp $\rightarrow$ Set where\\
 Top : $\forall$ {G u} $\rightarrow$ Ref (u :: G) (snd u)\\
 Pop : $\forall$ {G u v} $\rightarrow$ Ref G u $\rightarrow$ Ref (v :: G) u\\

slookup : $\forall$ {S t} $\rightarrow$ Stack S $\rightarrow$ Ref S t $\rightarrow$ Val t\\
slookup (v $\rhd$ xs) Top = v\\
slookup (v $\rhd$ xs) (Pop b$_1$) = slookup xs b$_1$\\

-- ** Ref **\\

data Ref : $\Gamma$ $\rightarrow$ TyExp $\rightarrow$ Set where\\
 Top : $\forall$ {G u} $\rightarrow$ Ref (u :: G) (snd u)\\
 Pop : $\forall$ {G u v} $\rightarrow$ Ref G u $\rightarrow$ Ref (v :: G) u\\

-- ** Exp **\\

data Exp : TyExp $\rightarrow$ $\Gamma$ $\rightarrow$ Bool $\rightarrow$ Set where\\
  var  : $\forall$ {ctx t b} $\rightarrow$ Ref ctx t $\rightarrow$ Exp t ctx b\\
  let$_1$ : $\forall$ {ctx t$_1$ t$_2$ b} $\rightarrow$ Exp t$_1$ ctx true $\rightarrow$ Exp t$_2$ (<true,t$_1$>  ::ctx) b $\rightarrow$ Exp t$_2$ ctx b\\


-- ** Eval **\\

eval : $\forall$ {t$_1$ ctx b} $\rightarrow$ (e : Exp t$_1$ ctx b) $\rightarrow$ Stack ctx $\rightarrow$ Val t$_1$\\
eval (var x) env = slookup env x\\
eval (let$_1$ e$_1$ e$_2$) env = eval e$_2$ ((eval e$_1$ env) $\rhd$ env)\\
\normalfont
\subsection{Type preservation is the type of the interpreter}
\section{The Second Semantics : compile \& exec}

\subsection{Specifying intermediate code}
\ttfamily
-- ** Code **

data Code : $\Gamma$ $\rightarrow$ $\Gamma$ $\rightarrow$ Set where\\
	LDS   : $\forall$ {S t b} $\rightarrow$ (f : Ref S t) $\rightarrow$ Code S (< b , t > :: S)\\
    POP   : $\forall$ {b S t$_1$ t$_2$} $\rightarrow$ Code (<b,t$_1$> :: (<true,t$_2$> :: S)) (<b,t$_1$> :: S)\\
\normalfont

\subsection{Implementing an Interpreter for Intermediate Code}
\ttfamily
-- ** Exec **

exec : {S S' : $\Gamma$} $\rightarrow$ Code S S' $\rightarrow$ Stack S $\rightarrow$ Stack S'\\
exec (LDS f) s = (slookup s f) $\rhd$ s\\
exec POP (v $\rhd$ (v$_1$ $\rhd$ s)) = v $\rhd$ s\\
\normalfont
\subsection{Converting between contexts}
\ttfamily
-- ** Converting between contexts **

trimEnv : $\Gamma$ $\rightarrow$ $\Gamma$\\
trimEnv [] = []\\
trimEnv (< true , x$_1$ > :: s) = < true , x$_1$ > :: trimEnv s\\
trimEnv (< false , x$_1$ > :: s) = trimEnv s\\

convertRef : $\forall$ {S t} $\rightarrow$ Ref (trimEnv S) t $\rightarrow$ Ref S t\\
convertRef {[]} ()\\
convertRef {< true , x$_1$ > :: S} Top = Top\\
convertRef {< true , x$_1$ > :: S} (Pop s) = Pop (convertRef s)\\
convertRef {< false , x$_1$ > :: S} s = Pop (convertRef s)\\
\normalfont

\subsection{Implementing the compiler to intermediate code}
\ttfamily
-- ** Compile ** 

compile : $\forall$ {b S t} $\rightarrow$ (e : Exp t (trimEnv S) b) $\rightarrow$ Code S (<b,t> :: S)\\
compile (var x) = LDS (convertRef x)\\
compile (let$_1$ e e$_1$) = compile e ++$_1$ (compile e$_1$ ++$_1$ POP)\\
\normalfont

\section{Compiler Correctness}
\ttfamily
trimStack : $\forall$ {S} $\rightarrow$ Stack S $\rightarrow$ Stack (trimEnv S)\\
trimStack {[]} x = empty\\
trimStack {< true , x$_1$ > :: S} (v $\rhd$ x$_2$) = v $\rhd$ (trimStack x$_2$)\\
trimStack {< false , x$_1$ > :: S} (v $\rhd$ x$_2$) = trimStack x$_2$\\


lemma : $\forall$ {S t} $\rightarrow$ (x : Ref (trimEnv S) t) $\rightarrow$ (s : Stack S) $\rightarrow$ (slookup (trimStack s) x) $\equiv$ (slookup s (convertRef x))\\
lemma {[]} () s\\
lemma {< true , t > :: S} Top (v $\rhd$ s) = refl\\
lemma {< true , x$_1$ > :: S} (Pop e) (v $\rhd$ s) = lemma e s\\
lemma {< false , x$_1$ > :: S} e (v $\rhd$ s) = lemma e s\\

correct : $\forall$ {b S t} $\rightarrow$ (e : Exp t (trimEnv S) b) $\rightarrow$ (s : Stack S) $\rightarrow$ ((eval e (trimStack s)) $\rhd$ s) â‰¡ (exec (compile e) s)\\
correct (var x) s with lemma x s\\
... | p with slookup (trimStack s) x | slookup s (convertRef x) \\
correct (var x) s | refl | .l | l = refl\\
correct (let$_1$ e e$_1$) s with correct e s\\
... | p1 with exec (compile e) s | eval e (trimStack s)\\
correct (let$_1$ e e$_1$) s | refl | .(p3 $\rhd$ s) | p3 with correct e$_1$ (\_$\rhd$\_ {true} p3 s)\\
... | p4 with exec (compile e$_1$) (\_$\rhd$\_ {true} p3 s) | eval e$_1$ (p3 $\rhd$ trimStack s)\\
correct (let$_1$ e e$_1$) s | refl | .(p3 $\rhd$ s) | p3 | refl | .(p6 $\rhd$ (p3 $\rhd$ s)) | p6 = refl\\
\normalfont
\section{Conclusion}
\section{Related work} %required by assignment description
A Certified Type-Preserving Compiler from Lambda Calculus to
Assembly Language \cite{Chlipala}. Here the author presents a certified compiler for a language similar to ours, with a machine-checked correctness proof written in Coq.

\begin{thebibliography}{9}
\bibitem{Chlipala}
	Adam Chlipala,
  	\emph{A Certified Type-Preserving Compiler from Lambda Calculus to
Assembly Language}.
  	Proceedings PLDI '07, p54-65, New York, 2007.
	
\end{thebibliography}
\end{document}