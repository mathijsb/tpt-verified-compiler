% !TEX encoding = UTF-8 Unicode
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Short Sectioned Assignment
% LaTeX Template
% Version 1.0 (5/5/12)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% Original author:
% Frits Wenneker (http://www.howtotex.com)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
% PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[paper=a4, fontsize=11pt]{scrartcl} % A4 paper and 11pt font size

\usepackage{dirtree}

\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs
\usepackage{fourier} % Use the Adobe Utopia font for the document - comment this line to return to the LaTeX default
\usepackage[english, dutch]{babel} % English language/hyphenation
\usepackage{amsmath,amsfonts,amsthm} % Math packages

\usepackage{lipsum} % Used for inserting dummy 'Lorem ipsum' text into the template
\usepackage{graphicx}

\usepackage{sectsty} % Allows customizing section commands
\allsectionsfont{\centering \normalfont\scshape} % Make all sections centered, the default font and small caps

\usepackage{fancyhdr} % Custom headers and footers
\pagestyle{fancyplain} % Makes all pages in the document conform to the custom headers and footers
\fancyhead{} % No page header - if you want one, create it in the same way as the footers below
\fancyfoot[L]{} % Empty left footer
\fancyfoot[C]{} % Empty center footer
\fancyfoot[R]{\thepage} % Page numbering for right footer
\renewcommand{\headrulewidth}{0pt} % Remove header underlines
\renewcommand{\footrulewidth}{0pt} % Remove footer underlines
\setlength{\headheight}{13.6pt} % Customize the height of the header

\usepackage{fancyvrb}
\DefineVerbatimEnvironment{code}{Verbatim}{fontsize=\small}
\DefineVerbatimEnvironment{example}{Verbatim}{fontsize=\small}

\textheight = 720px

\numberwithin{equation}{section} % Number equations within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)
\numberwithin{figure}{section} % Number figures within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)
\numberwithin{table}{section} % Number tables within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)

\setlength\parindent{0pt} % Removes all indentation from paragraphs - comment this line for an assignment with lots of text

%----------------------------------------------------------------------------------------
% TITLE SECTION
%----------------------------------------------------------------------------------------

\newcommand{\horrule}[1]{\rule{\linewidth}{#1}} % Create horizontal rule command with 1 argument of height

\title{ 
\normalfont \normalsize 
\textsc{Universiteit Utrecht, Department of Information and Computing Sciences} \\ [25pt] % Your university, school and/or department name(s)
\horrule{0.5pt} \\[0.4cm] % Thin top horizontal rule
\huge Theory of Programming and Types\\ % The assignment title
\horrule{2pt} \\[0.5cm] % Thick bottom horizontal rule
}

\author{Mathijs Baaijens\\ Nico Naus, 3472353} % Your name

\begin{document}

\maketitle % Print the title

%----------------------------------------------------------------------------------------

\section{abstract}
In this paper we will describe an extension to the type-correct, stack-safe, provably correct expression compiler described in the paper "A type-correct, stack-safe, provably correct expression compiler in Epigram". Our extension adds 'let' bindings to this compiler. We will describe the following components of our extension:
* evaluation semantics
* compiler
* interpreter
* correctness proof

\section{Introduction}
\section{The First Semantics : eval}

-- ** Types & values **

data TyExp : Set where
  TyNat  : TyExp
  TyBool : TyExp

data Val : TyExp -> Set where
  nat : ℕ -> Val TyNat
  bool : Bool -> Val TyBool

-- ** Tuples **

data _×_ (A B : Set) : Set where
  <_,_> : A -> B -> A × B

fst : {A B : Set} -> A × B -> A
fst < x , y > = x

snd : {A B : Set} -> A × B -> B
snd < x , y > = y

-- ** Context **

Γ = List (Bool × TyExp)

-- ** Stack **

data Stack : Γ -> Set where
  empty : Stack []
  _|>_ : forall {b t s} -> (v : Val t) -> (xs : Stack s) -> Stack (< b , t > ∷ s)

-- ** References **

data Ref : Γ -> TyExp -> Set where
 Top : forall {G u} -> Ref (u ∷ G) (snd u)
 Pop : forall {G u v} -> Ref G u -> Ref (v ∷ G) u

slookup : forall {S t} -> Stack S -> Ref S t -> Val t
slookup (v |> xs) Top = v
slookup (v |> xs) (Pop b₁) = slookup xs b₁

-- ** Ref **

data Ref : Γ -> TyExp -> Set where
 Top : forall {G u} -> Ref (u ∷ G) (snd u)
 Pop : forall {G u v} -> Ref G u -> Ref (v ∷ G) u

-- ** Exp **

data Exp : TyExp -> Γ -> Bool -> Set where
  var  : forall {ctx t b} -> Ref ctx t -> Exp t ctx b
  let₁ : forall {ctx t₁ t₂ b} -> Exp t₁ ctx true -> Exp t₂ (< true , t₁ >  ∷ ctx) b -> Exp t₂ ctx b


-- ** Eval **

eval : forall {t₁ ctx b} -> (e : Exp t₁ ctx b) -> Stack ctx -> Val t₁
eval (var x) env = slookup env x
eval (let₁ e₁ e₂) env = eval e₂ ((eval e₁ env) |> env)

\subsection{Type preservation is the type of the interpreter}
\section{The Second Semantics : compile \& exec}

\subsection{Specifying intermediate code}

-- ** Code **

data Code : Γ -> Γ -> Set where
	LDS   : forall {S t b} -> (f : Ref S t) -> Code S (< b , t > ∷ S)
    POP   : forall {b S t₁ t₂} -> Code (< b , t₁ > ∷ (< true , t₂ > ∷ S)) (< b , t₁ > ∷ S)


\subsection{Implementing an Interpreter for Intermediate Code}

-- ** Exec **

exec : {S S' : Γ} -> Code S S' -> Stack S -> Stack S'
exec (LDS f) s = (slookup s f) |> s
exec POP (v |> (v₁ |> s)) = v |> s

\subsection{Converting between contexts}

-- ** Converting between contexts **

trimEnv : Γ -> Γ
trimEnv [] = []
trimEnv (< true , x₁ > ∷ s) = < true , x₁ > ∷ trimEnv s
trimEnv (< false , x₁ > ∷ s) = trimEnv s

convertRef : forall {S t} -> Ref (trimEnv S) t -> Ref S t
convertRef {[]} ()
convertRef {< true , x₁ > ∷ S} Top = Top
convertRef {< true , x₁ > ∷ S} (Pop s) = Pop (convertRef s)
convertRef {< false , x₁ > ∷ S} s = Pop (convertRef s)


\subsection{Implementing the compiler to intermediate code}

-- ** Compile ** 

compile : forall {b S t} -> (e : Exp t (trimEnv S) b) -> Code S (< b , t > ∷ S)
compile (var x) = LDS (convertRef x)
compile (let₁ e e₁) = compile e ++₁ (compile e₁ ++₁ POP)


\section{Compiler Correctness}

trimStack : forall {S} -> Stack S -> Stack (trimEnv S)
trimStack {[]} x = empty
trimStack {< true , x₁ > ∷ S} (v |> x₂) = v |> (trimStack x₂)
trimStack {< false , x₁ > ∷ S} (v |> x₂) = trimStack x₂


lemma : forall {S t} -> (x : Ref (trimEnv S) t) -> (s : Stack S) -> (slookup (trimStack s) x) ≡ (slookup s (convertRef x))
lemma {[]} () s
lemma {< true , t > ∷ S} Top (v |> s) = refl
lemma {< true , x₁ > ∷ S} (Pop e) (v |> s) = lemma e s
lemma {< false , x₁ > ∷ S} e (v |> s) = lemma e s

correct : forall {b S t} -> (e : Exp t (trimEnv S) b) -> (s : Stack S) -> ((eval e (trimStack s)) |> s) ≡ (exec (compile e) s)
correct (var x) s with lemma x s
... | p with slookup (trimStack s) x | slookup s (convertRef x) 
correct (var x) s | refl | .l | l = refl
correct (let₁ e e₁) s with correct e s
... | p1 with exec (compile e) s | eval e (trimStack s)
correct (let₁ e e₁) s | refl | .(p3 |> s) | p3 with correct e₁ (_|>_ {true} p3 s)
... | p4 with exec (compile e₁) (_|>_ {true} p3 s) | eval e₁ (p3 |> trimStack s)
correct (let₁ e e₁) s | refl | .(p3 |> s) | p3 | refl | .(p6 |> (p3 |> s)) | p6 = refl


\section{Conclusion}
\section{Related work} %required by assignment description
A Certified Type-Preserving Compiler from Lambda Calculus to
Assembly Language \cite{Chlipala}. Here the author presents a certified compiler for a language similar to ours, with a machine-checked correctness proof written in Coq.

\begin{thebibliography}{9}
\bibitem{Chlipala}
	Adam Chlipala,
  	\emph{A Certified Type-Preserving Compiler from Lambda Calculus to
Assembly Language}.
  	Proceedings PLDI '07, p54-65, New York, 2007.
	
\end{thebibliography}
\end{document}